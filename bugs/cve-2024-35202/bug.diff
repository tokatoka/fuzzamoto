diff --git a/src/blockencodings.cpp b/src/blockencodings.cpp
index 4990048..b6e5d24 100644
--- a/src/blockencodings.cpp
+++ b/src/blockencodings.cpp
@@ -63,8 +63,8 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c
         return READ_STATUS_INVALID;
     if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_WEIGHT / MIN_SERIALIZABLE_TRANSACTION_WEIGHT)
         return READ_STATUS_INVALID;
-
-    if (!header.IsNull() || !txn_available.empty()) return READ_STATUS_INVALID;
+    
+    assert(header.IsNull() && txn_available.empty());
 
     header = cmpctblock.header;
     txn_available.resize(cmpctblock.BlockTxCount());
@@ -182,7 +182,7 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c
 
 bool PartiallyDownloadedBlock::IsTxAvailable(size_t index) const
 {
-    if (header.IsNull()) return false;
+    assert(!header.IsNull());
 
     assert(index < txn_available.size());
     return txn_available[index] != nullptr;
@@ -190,7 +190,7 @@ bool PartiallyDownloadedBlock::IsTxAvailable(size_t index) const
 
 ReadStatus PartiallyDownloadedBlock::FillBlock(CBlock& block, const std::vector<CTransactionRef>& vtx_missing, bool segwit_active)
 {
-    if (header.IsNull()) return READ_STATUS_INVALID;
+    assert(!header.IsNull());
 
     uint256 hash = header.GetHash();
     block = header;
diff --git a/src/net_processing.cpp b/src/net_processing.cpp
index 542d3c5..2191782 100644
--- a/src/net_processing.cpp
+++ b/src/net_processing.cpp
@@ -3343,16 +3343,6 @@ void PeerManagerImpl::ProcessCompactBlockTxns(CNode& pfrom, Peer& peer, const Bl
 
         PartiallyDownloadedBlock& partialBlock = *range_flight.first->second.second->partialBlock;
 
-        if (partialBlock.header.IsNull()) {
-            // It is possible for the header to be empty if a previous call to FillBlock wiped the header, but left
-            // the PartiallyDownloadedBlock pointer around (i.e. did not call RemoveBlockRequest). In this case, we
-            // should not call LookupBlockIndex below.
-            RemoveBlockRequest(block_transactions.blockhash, pfrom.GetId());
-            Misbehaving(peer, "previous compact block reconstruction attempt failed");
-            LogDebug(BCLog::NET, "Peer %d sent compact block transactions multiple times", pfrom.GetId());
-            return;
-        }
-
         // We should not have gotten this far in compact block processing unless it's attached to a known header
         const CBlockIndex* prev_block{Assume(m_chainman.m_blockman.LookupBlockIndex(partialBlock.header.hashPrevBlock))};
         ReadStatus status = partialBlock.FillBlock(*pblock, block_transactions.txn,
